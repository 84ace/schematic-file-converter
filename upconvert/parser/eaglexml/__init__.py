#!/usr/bin/env python2
""" The Eagle XML Format Parser """

# upconvert.py - A universal hardware design file format converter using
# Format:       upverter.com/resources/open-json-format/
# Development:  github.com/upverter/schematic-file-converter
#
# Copyright 2011 Upverter, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections import defaultdict

from upconvert.core.design import Design
from upconvert.core.annotation import Annotation
from upconvert.core.components import Component, Symbol, Body, Pin
from upconvert.core.component_instance import ComponentInstance, SymbolAttribute
from upconvert.core.net import Net, NetPoint
from upconvert.core.shape import Label, Line, Rectangle

from upconvert.parser.eaglexml.generated import parse


class EagleXML(object):
    """ The Eagle XML Format Parser.

    This parser uses code generated by generateDS.py which converts an xsd
    file to a set of python objects with parse and export functions.
    That code is in generated.py. It was created by the following steps:

      1. Started with eagle.dtd from Eagle 6.2.0.
      2. Removed inline comments in dtd (was breaking conversion to xsd).
         The dtd is also stored in this directory.
      3. Converted to eagle.xsd using dtd2xsd.pl from w3c.
         The xsd is also stored in this directory.
      4. Run a modified version of generateDS.py with the following arguments:
           --silence --external-encoding=utf-8 -o generated.py
     """

    MULT = 90 / 25.4 # mm to 90 dpi

    def __init__(self):
        self.design = Design()

        # map components to gate names to symbol indices
        self.cpt2gate2symbol_index = defaultdict(dict)

        # map components to gate names to annotation maps, dicts from
        # strings (name|value) to Annotations. These represent the
        # >NAME and >VALUE texts on eagle components, which must be
        # converted into component instance annotations since their
        # contents depend on the component instance name and value.
        self.cpt2gate2ann_map = defaultdict(dict)


    @staticmethod
    def auto_detect(filename):
        """ Return our confidence that the given file is an
        eagle xml schematic """

        with open(filename, 'r') as f:
            data = f.read(4096)
        confidence = 0.0
        if 'eagle.dtd' in data:
            confidence += 0.9
        return confidence


    def parse(self, filename):
        """ Parse an Eagle XML file into a design """

        root = parse(filename)

        self.make_components(root)
        self.make_component_instances(root)
        self.make_nets(root)

        return self.design


    def make_components(self, root):
        """ Construct openjson components from an eagle model. """

        for lib in get_subattr(root, 'drawing.schematic.libraries.library', ()):
            for deviceset in get_subattr(lib, 'devicesets.deviceset', ()):
                for cpt in self.make_deviceset_components(lib, deviceset):
                    self.design.components.add_component(cpt.name, cpt)


    def make_deviceset_components(self, lib, deviceset):
        """ Construct a set of openjson components for a deviceset in a library. """

        for device in get_subattr(deviceset, 'devices.device'):
            # map pin names to pin numbers for this device
            pinmap = {}
            for connect in get_subattr(device, 'connects.connect', ()):
                pinmap[connect.pin] = connect.pad

            cpt = Component(lib.name + ':' + deviceset.name + ':' + device.name)

            for gate in get_subattr(deviceset, 'gates.gate'):
                symbol = Symbol()
                cpt.add_symbol(symbol)
                self.cpt2gate2symbol_index[cpt][gate.name] = len(cpt.symbols) - 1
                body, ann_map = self.make_body_from_symbol(lib, gate.symbol, pinmap)
                symbol.add_body(body)
                self.cpt2gate2ann_map[cpt][gate.name] = ann_map

            yield cpt


    def make_body_from_symbol(self, lib, symbol_name, pinmap):
        """ Contruct an openjson Body from an eagle symbol in a library. """

        body = Body()

        symbol = [s for s in get_subattr(lib, 'symbols.symbol')
                  if s.name == symbol_name][0]

        for wire in symbol.wire:
            body.add_shape(Line((self.make_length(wire.x1),
                                 self.make_length(wire.y1)),
                                (self.make_length(wire.x2),
                                 self.make_length(wire.y2))))

        for rect in symbol.rectangle:
            x = self.make_length(rect.x1)
            y = self.make_length(rect.y1)
            width = self.make_length(rect.x2) - x
            height = self.make_length(rect.y2) - y
            body.add_shape(Rectangle(x, y + height, width, height))

        for pin in symbol.pin:
            connect_point = (self.make_length(pin.x), self.make_length(pin.y))
            null_point = self.get_pin_null_point(connect_point,
                                                 pin.length, pin.rot)
            # TODO: pin labels
            body.add_pin(Pin(pinmap.get(pin.name, pin.name),
                             null_point, connect_point))

        ann_map = {}

        for text in symbol.text:
            x = self.make_length(text.x)
            y = self.make_length(text.y)
            content = '' if text.valueOf_ is None else text.valueOf_
            rotation = self.make_angle('0' if text.rot is None else text.rot)
            if content == '>NAME':
                ann_map['name'] = Annotation(content, x, y, rotation, True)
            elif content == '>VALUE':
                ann_map['value'] = Annotation(content, x, y, rotation, True)
            else:
                body.add_shape(Label(x, y, content, 'left', rotation))

        return body, ann_map


    def get_pin_null_point(self, (x, y), length, rotation):
        """ Return the null point of a pin given its connect point, length, and rotation. """

        if length == 'middle':
            distance = 18 # .2 inches
        elif length == 'long':
            distance = 27 # .3 inches TODO: find right value
        else:
            distance = 9  # .1 inches TODO: find right value

        if rotation == 'R90':
            return (x, y + distance)
        elif rotation == 'R180':
            return (x - distance, y)
        elif rotation == 'R270':
            return (x, y - distance)
        else:
            return (x + distance, y)


    def make_component_instances(self, root):
        """ Construct openjson component instances from an eagle model. """

        parts = dict((p.name, p) for p
                     in get_subattr(root, 'drawing.schematic.parts.part', ()))

        for sheet in get_subattr(root, 'drawing.schematic.sheets.sheet', ()):
            for instance in get_subattr(sheet, 'instances.instance', ()):
                inst = self.make_component_instance(parts, instance)
                self.design.add_component_instance(inst)


    def make_component_instance(self, parts, instance):
        """ Construct an openjson component instance from an eagle instance. """

        part = parts[instance.part]

        library_id = part.library + ':' + part.deviceset + ':' + part.device

        cpt = self.design.components.components[library_id]

        inst = ComponentInstance(instance.part, library_id,
                                 self.cpt2gate2symbol_index[cpt][instance.gate])

        # TODO: handle mirror
        # TODO: handle smashed?
        attr = SymbolAttribute(self.make_length(instance.x),
                               self.make_length(instance.y),
                               self.make_angle(instance.rot or '0'))

        inst.add_symbol_attribute(attr)

        return inst


    def make_nets(self, root):
        """ Construct openjson nets from an eagle model. """

        for sheet in get_subattr(root, 'drawing.schematic.sheets.sheet', ()):
            for net in get_subattr(sheet, 'nets.net', ()):
                self.design.add_net(self.make_net(net))


    def make_net(self, net):
        """ Construct an openjson net from an eagle net. """

        points = {} # (x, y) -> NetPoint

        def get_point(x, y):
            """ Return a new or existing NetPoint for an (x,y) point """
            point = (self.make_length(x), self.make_length(y))
            if point not in points:
                points[point] = NetPoint('%da%d' % point, point[0], point[1])
            return points[point]

        onet = Net(net.name)

        for segment in get_subattr(net, 'segment', ()):
            for wire in get_subattr(segment, 'wire', ()):
                onet.connect((get_point(wire.x1, wire.y1),
                              get_point(wire.x2, wire.y2)))

        return onet


    def make_length(self, value):
        """ Make an openjson length measurement from an eagle length. """

        return int(round(float(value) * self.MULT))


    def make_angle(self, value):
        """ Make an openjson angle measurement from an eagle angle. """

        angle = float(value.lstrip('MSR')) / 180

        return angle if angle == 0.0 else 2.0 - angle


def get_subattr(obj, name, default=None):
    """ Return an attribute given a dotted name, or the default if
    there is not attribute or the attribute is None. """

    for attr in name.split('.'):
        obj = getattr(obj, attr, None)

    return default if obj is None else obj
